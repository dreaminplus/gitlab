# frozen_string_literal: true

module API
  class VulnerabilityExports < Grape::API
    include ::API::Helpers::VulnerabilitiesHooks
    include ::Gitlab::Utils::StrongMemoize

    helpers do
      def vulnerability_export
        strong_memoize(:vulnerability_export) do
          ::Vulnerabilities::Export.find(params[:id])
        end
      end

      def process_create_request_for(exportable)
        vulnerability_export = ::VulnerabilityExports::CreateService.new(
          exportable, current_user, format: params[:export_format]
        ).execute

        if vulnerability_export.persisted?
          status :created
          present vulnerability_export, with: EE::API::Entities::VulnerabilityExport
        else
          render_validation_error!(vulnerability_export)
        end
      end
    end

    before do
      authenticate!
    end

    resource :projects, requirements: API::NAMESPACE_OR_PROJECT_REQUIREMENTS do
      params do
        requires :id, type: String, desc: 'The ID of a project'
        optional :export_format, type: String, desc: 'The format of export to be generated',
                 default: ::Vulnerabilities::Export.formats.each_key.first,
                 values: ::Vulnerabilities::Export.formats.keys
      end
      desc 'Generate an export of project vulnerability findings' do
        success EE::API::Entities::VulnerabilityExport
      end

      before do
        not_found! unless Feature.enabled?(:first_class_vulnerabilities, user_project)
      end

      post ':id/vulnerability_exports' do
        authorize! :create_vulnerability_export, user_project

        process_create_request_for(user_project)
      end
    end

    resource :users, requirements: API::USER_REQUIREMENTS do
      params do
        requires :user_id, type: String, desc: 'The ID or username of the user'
        optional :export_format, type: String, desc: 'The format of export to be generated',
                 default: ::Vulnerabilities::Export.formats.each_key.first,
                 values: ::Vulnerabilities::Export.formats.keys
      end
      post ':user_id/vulnerability_exports' do
        # TODO: Enable this after the other MR gets merged
        # authorize! :create_vulnerability_export, current_user

        process_create_request_for(current_user)
      end
    end

    desc 'Get single project vulnerability export' do
      success EE::API::Entities::VulnerabilityExport
    end
    get 'vulnerability_exports/:id' do
      authorize! :read_vulnerability_export, vulnerability_export

      unless vulnerability_export.completed?
        ::Gitlab::PollingInterval.set_api_header(self, interval: 5_000)
        status :accepted
      end

      present vulnerability_export,
              with: EE::API::Entities::VulnerabilityExport
    end

    desc 'Download single project vulnerability export'
    get 'vulnerability_exports/:id/download' do
      authorize! :read_vulnerability_export, vulnerability_export

      if vulnerability_export.finished?
        present_carrierwave_file!(vulnerability_export.file)
      else
        not_found!('Vulnerability Export')
      end
    end
  end
end
