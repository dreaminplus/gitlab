# frozen_string_literal: true

require 'spec_helper'

describe API::VulnerabilityExports do
  include AccessMatchersForRequest

  before do
    stub_licensed_features(security_dashboard: true)
  end

  let_it_be(:user) { create(:user) }
  let_it_be(:project) { create(:project, :with_vulnerabilities) }

  let(:project_vulnerability_exports_path) { "/projects/#{project.id}/vulnerability_exports" }
  let(:project_vulnerability_export_path) { "#{project_vulnerability_exports_path}/#{vulnerability_export.id}" }

  describe 'POST /projects/:id/vulnerability_exports' do
    let(:format) { 'csv' }

    subject(:create_vulnerability_export) { post api(project_vulnerability_exports_path, user), params: { export_format: format } }

    context 'with an authorized user with proper permissions' do
      before do
        project.add_developer(user)
      end

      context 'when format is csv' do
        it 'returns information about new vulnerability export' do
          create_vulnerability_export

          expect(response).to have_gitlab_http_status(:created)
          expect(response).to match_response_schema('public_api/v4/vulnerability_export', dir: 'ee')
        end

        it 'schedules job for export' do
          expect(::VulnerabilityExports::ExportWorker).to receive(:perform_async).with(project.id, anything)

          create_vulnerability_export
        end
      end

      context 'when format is invalid' do
        let(:format) { 'invalid' }

        it 'returns error message' do
          create_vulnerability_export

          expect(response).to have_gitlab_http_status(:bad_request)
          expect(json_response).to eq('error' => 'export_format does not have a valid value')
        end

        it 'schedules job for export' do
          expect(::VulnerabilityExports::ExportWorker).not_to receive(:perform_async)

          create_vulnerability_export
        end
      end

      it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
    end

    describe 'permissions' do
      it { expect { create_vulnerability_export }.to be_allowed_for(:admin) }
      it { expect { create_vulnerability_export }.to be_allowed_for(:owner).of(project) }
      it { expect { create_vulnerability_export }.to be_allowed_for(:maintainer).of(project) }
      it { expect { create_vulnerability_export }.to be_allowed_for(:developer).of(project) }
      it { expect { create_vulnerability_export }.to be_allowed_for(:auditor) }

      it { expect { create_vulnerability_export }.to be_denied_for(:reporter).of(project) }
      it { expect { create_vulnerability_export }.to be_denied_for(:guest).of(project) }
      it { expect { create_vulnerability_export }.to be_denied_for(:anonymous) }
    end
  end

  describe 'GET /projects/:id/vulnerability_exports/:export_id' do
    let!(:vulnerability_export) { create(:vulnerability_export, :finished, :csv, :with_csv_file, project: project) }

    subject(:get_vulnerability_export) { get api(project_vulnerability_export_path, user) }

    context 'with an authorized user with proper permissions' do
      before do
        project.add_developer(user)
      end

      it 'returns information about vulnerability export' do
        get_vulnerability_export

        expect(response).to have_gitlab_http_status(:ok)
        expect(response).to match_response_schema('public_api/v4/vulnerability_export', dir: 'ee')
        expect(json_response['id']).to eq vulnerability_export.id
      end

      it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
    end

    describe 'permissions' do
      it { expect { get_vulnerability_export }.to be_allowed_for(:admin) }
      it { expect { get_vulnerability_export }.to be_allowed_for(:owner).of(project) }
      it { expect { get_vulnerability_export }.to be_allowed_for(:maintainer).of(project) }
      it { expect { get_vulnerability_export }.to be_allowed_for(:developer).of(project) }
      it { expect { get_vulnerability_export }.to be_allowed_for(:auditor) }

      it { expect { get_vulnerability_export }.to be_denied_for(:reporter).of(project) }
      it { expect { get_vulnerability_export }.to be_denied_for(:guest).of(project) }
      it { expect { get_vulnerability_export }.to be_denied_for(:anonymous) }
    end
  end

  describe 'GET /projects/:id/vulnerability_exports/:export_id/download' do
    let!(:vulnerability_export) { create(:vulnerability_export, :finished, :csv, :with_csv_file, project: project) }

    subject(:download_vulnerability_export) { get api("#{project_vulnerability_export_path}/download", user) }

    context 'with an authorized user with proper permissions' do
      before do
        project.add_developer(user)
      end

      context 'when export is running' do
        let!(:vulnerability_export) { create(:vulnerability_export, :running, :csv, project: project) }

        it 'renders 202 with information about job in progress with poll interval' do
          download_vulnerability_export

          expect(response).to have_gitlab_http_status(:accepted)
          expect(response.headers['Poll-Interval']).to eq '5000'
          expect(json_response).to eq('message' => 'Job to generate Vulnerability Export is in progress')
        end
      end

      context 'when export is failed' do
        let!(:vulnerability_export) { create(:vulnerability_export, :failed, :csv, project: project) }

        it 'renders 404' do
          download_vulnerability_export

          expect(response).to have_gitlab_http_status(:not_found)
          expect(json_response).to eq('message' => '404 Vulnerability Export Not Found')
        end
      end

      context 'when export is finished' do
        let!(:vulnerability_export) { create(:vulnerability_export, :finished, :csv, :with_csv_file, project: project) }

        it 'renders 200 with CSV file' do
          download_vulnerability_export

          expect(response).to have_gitlab_http_status(:ok)
          expect(response.body).to include 'Scanner Type,Scanner Name,Vulnerability,Details,Additional Info,Severity,CVE'
          expect(response.headers['Poll-Interval']).to be_blank
        end
      end

      it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
    end

    describe 'permissions' do
      it { expect { download_vulnerability_export }.to be_allowed_for(:admin) }
      it { expect { download_vulnerability_export }.to be_allowed_for(:owner).of(project) }
      it { expect { download_vulnerability_export }.to be_allowed_for(:maintainer).of(project) }
      it { expect { download_vulnerability_export }.to be_allowed_for(:developer).of(project) }
      it { expect { download_vulnerability_export }.to be_allowed_for(:auditor) }

      it { expect { download_vulnerability_export }.to be_denied_for(:reporter).of(project) }
      it { expect { download_vulnerability_export }.to be_denied_for(:guest).of(project) }
      it { expect { download_vulnerability_export }.to be_denied_for(:anonymous) }
    end
  end

  # describe 'POST /projects/:id/vulnerabilities' do
  #   let_it_be(:project) { create(:project) }
  #   let(:finding) { create(:vulnerabilities_occurrence, project: project) }
  #   let(:finding_id) { finding.id }
  #   let(:expected_error_messages) { { 'base' => ['finding is not found or is already attached to a vulnerability'] } }

  #   subject(:create_vulnerability) { post api(project_vulnerability_export_path, user), params: { finding_id: finding_id } }

  #   context 'with an authorized user with proper permissions' do
  #     before do
  #       project.add_developer(user)
  #     end

  #     it 'creates a vulnerability from finding and attaches it to the vulnerability' do
  #       expect { subject }.to change { project.vulnerabilities.count }.by(1)
  #       expect(project.vulnerabilities.last).to(
  #         have_attributes(
  #           author: user,
  #           title: finding.name,
  #           state: 'detected',
  #           severity: finding.severity,
  #           severity_overridden: false,
  #           confidence: finding.confidence,
  #           confidence_overridden: false,
  #           report_type: finding.report_type
  #         ))

  #       expect(response).to have_gitlab_http_status(:created)
  #       expect(response).to match_response_schema('public_api/v4/vulnerability', dir: 'ee')
  #     end

  #     context 'when finding id is unknown' do
  #       let(:finding_id) { 0 }

  #       it 'responds with expected error' do
  #         subject

  #         expect(response).to have_gitlab_http_status(:bad_request)
  #         expect(json_response['message']).to eq(expected_error_messages)
  #       end
  #     end

  #     context 'when a vulnerability already exists for a specific finding' do
  #       before do
  #         create(:vulnerability, findings: [finding], project: finding.project)
  #       end

  #       it 'rejects creation of a new vulnerability from this finding' do
  #         subject

  #         expect(response).to have_gitlab_http_status(:bad_request)
  #         expect(json_response['message']).to eq(expected_error_messages)
  #       end
  #     end

  #     it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
  #   end

  #   describe 'permissions' do
  #     it { expect { create_vulnerability }.to be_allowed_for(:admin) }
  #     it { expect { create_vulnerability }.to be_allowed_for(:owner).of(project) }
  #     it { expect { create_vulnerability }.to be_allowed_for(:maintainer).of(project) }
  #     it { expect { create_vulnerability }.to be_allowed_for(:developer).of(project) }

  #     it { expect { create_vulnerability }.to be_denied_for(:auditor) }
  #     it { expect { create_vulnerability }.to be_denied_for(:reporter).of(project) }
  #     it { expect { create_vulnerability }.to be_denied_for(:guest).of(project) }
  #     it { expect { create_vulnerability }.to be_denied_for(:anonymous) }
  #   end
  # end

  # describe 'POST /vulnerabilities:id/dismiss' do
  #   before do
  #     create_list(:vulnerabilities_occurrence, 2, vulnerability: vulnerability, project: vulnerability.project)
  #   end

  #   let_it_be(:project) { create(:project, :with_vulnerabilities) }
  #   let(:vulnerability) { project.vulnerabilities.first }
  #   let(:vulnerability_export_id) { vulnerability.id }

  #   subject(:dismiss_vulnerability) { post api("/vulnerabilities/#{vulnerability_export_id}/dismiss", user) }

  #   context 'with an authorized user with proper permissions' do
  #     before do
  #       project.add_developer(user)
  #     end

  #     it 'dismisses a vulnerability and its associated findings' do
  #       Timecop.freeze do
  #         dismiss_vulnerability

  #         expect(response).to have_gitlab_http_status(:created)
  #         expect(response).to match_response_schema('public_api/v4/vulnerability', dir: 'ee')

  #         expect(vulnerability.reload).to(
  #           have_attributes(state: 'dismissed', dismissed_by: user, dismissed_at: be_like_time(Time.current)))
  #         expect(vulnerability.findings).to all have_vulnerability_dismissal_feedback
  #       end
  #     end

  #     it_behaves_like 'responds with "not found" for an unknown vulnerability ID'

  #     context 'when there is a dismissal error' do
  #       before do
  #         Grape::Endpoint.before_each do |endpoint|
  #           allow(endpoint).to receive(:find_vulnerability!).and_wrap_original do |method, *args|
  #             vulnerability = method.call(*args)

  #             errors = ActiveModel::Errors.new(vulnerability)
  #             errors.add(:base, 'something went wrong')

  #             allow(vulnerability).to receive(:valid?).and_return(false)
  #             allow(vulnerability).to receive(:errors).and_return(errors)

  #             vulnerability
  #           end
  #         end
  #       end

  #       after do
  #         # resetting according to the https://github.com/ruby-grape/grape#stubbing-helpers
  #         Grape::Endpoint.before_each nil
  #       end

  #       it 'responds with error' do
  #         dismiss_vulnerability

  #         expect(response).to have_gitlab_http_status(:bad_request)
  #         expect(json_response['message']).to eq('base' => ['something went wrong'])
  #       end
  #     end

  #     context 'if a vulnerability is already dismissed' do
  #       let(:vulnerability) { create(:vulnerability, :dismissed, project: project) }

  #       it 'responds with 304 Not Modified' do
  #         dismiss_vulnerability

  #         expect(response).to have_gitlab_http_status(:not_modified)
  #       end
  #     end

  #     it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
  #   end

  #   describe 'permissions' do
  #     it { expect { dismiss_vulnerability }.to be_allowed_for(:admin) }
  #     it { expect { dismiss_vulnerability }.to be_allowed_for(:owner).of(project) }
  #     it { expect { dismiss_vulnerability }.to be_allowed_for(:maintainer).of(project) }
  #     it { expect { dismiss_vulnerability }.to be_allowed_for(:developer).of(project) }

  #     it { expect { dismiss_vulnerability }.to be_denied_for(:auditor) }
  #     it { expect { dismiss_vulnerability }.to be_denied_for(:reporter).of(project) }
  #     it { expect { dismiss_vulnerability }.to be_denied_for(:guest).of(project) }
  #     it { expect { dismiss_vulnerability }.to be_denied_for(:anonymous) }
  #   end
  # end

  # describe 'POST /vulnerabilities/:id/resolve' do
  #   before do
  #     create_list(:vulnerabilities_finding, 2, vulnerability: vulnerability)
  #   end

  #   let_it_be(:project) { create(:project, :with_vulnerabilities) }
  #   let(:vulnerability) { project.vulnerabilities.first }
  #   let(:vulnerability_export_id) { vulnerability.id }

  #   subject(:resolve_vulnerability) { post api("/vulnerabilities/#{vulnerability_export_id}/resolve", user) }

  #   context 'with an authorized user with proper permissions' do
  #     before do
  #       project.add_developer(user)
  #     end

  #     it 'resolves a vulnerability and its associated findings' do
  #       Timecop.freeze do
  #         resolve_vulnerability

  #         expect(response).to have_gitlab_http_status(:created)
  #         expect(response).to match_response_schema('public_api/v4/vulnerability', dir: 'ee')

  #         expect(vulnerability.reload).to(
  #           have_attributes(state: 'resolved', resolved_by: user, resolved_at: be_like_time(Time.current)))
  #         expect(vulnerability.findings).to all have_attributes(state: 'resolved')
  #       end
  #     end

  #     it_behaves_like 'responds with "not found" for an unknown vulnerability ID'

  #     context 'when the vulnerability is already resolved' do
  #       let(:vulnerability) { create(:vulnerability, :resolved, project: project) }

  #       it 'responds with 304 Not Modified response' do
  #         resolve_vulnerability

  #         expect(response).to have_gitlab_http_status(:not_modified)
  #       end
  #     end

  #     it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
  #   end

  #   describe 'permissions' do
  #     it { expect { resolve_vulnerability }.to be_allowed_for(:admin) }
  #     it { expect { resolve_vulnerability }.to be_allowed_for(:owner).of(project) }
  #     it { expect { resolve_vulnerability }.to be_allowed_for(:maintainer).of(project) }
  #     it { expect { resolve_vulnerability }.to be_allowed_for(:developer).of(project) }

  #     it { expect { resolve_vulnerability }.to be_denied_for(:auditor) }
  #     it { expect { resolve_vulnerability }.to be_denied_for(:reporter).of(project) }
  #     it { expect { resolve_vulnerability }.to be_denied_for(:guest).of(project) }
  #     it { expect { resolve_vulnerability }.to be_denied_for(:anonymous) }
  #   end
  # end

  # describe 'POST /vulnerabilities/:id/confirm' do
  #   before do
  #     create_list(:vulnerabilities_finding, 2, vulnerability: vulnerability)
  #   end

  #   let_it_be(:project) { create(:project, :with_vulnerabilities) }
  #   let(:vulnerability) { project.vulnerabilities.first }
  #   let(:vulnerability_export_id) { vulnerability.id }

  #   subject(:confirm_vulnerability) { post api("/vulnerabilities/#{vulnerability_export_id}/confirm", user) }

  #   context 'with an authorized user with proper permissions' do
  #     before do
  #       project.add_developer(user)
  #     end

  #     it 'confirms a vulnerability and its associated findings' do
  #       Timecop.freeze do
  #         confirm_vulnerability

  #         expect(response).to have_gitlab_http_status(:created)
  #         expect(response).to match_response_schema('public_api/v4/vulnerability', dir: 'ee')

  #         expect(vulnerability.reload).to(
  #           have_attributes(state: 'confirmed', confirmed_by: user, confirmed_at: be_like_time(Time.current)))
  #         expect(vulnerability.findings).to all have_attributes(state: 'confirmed')
  #       end
  #     end

  #     it_behaves_like 'responds with "not found" for an unknown vulnerability ID'

  #     context 'when the vulnerability is already confirmed' do
  #       let(:vulnerability) { create(:vulnerability, :confirmed, project: project) }

  #       it 'responds with 304 Not Modified response' do
  #         confirm_vulnerability

  #         expect(response).to have_gitlab_http_status(:not_modified)
  #       end
  #     end

  #     it_behaves_like 'forbids access to vulnerability API endpoint in case of disabled features'
  #   end

  #   describe 'permissions' do
  #     it { expect { confirm_vulnerability }.to be_allowed_for(:admin) }
  #     it { expect { confirm_vulnerability }.to be_allowed_for(:owner).of(project) }
  #     it { expect { confirm_vulnerability }.to be_allowed_for(:maintainer).of(project) }
  #     it { expect { confirm_vulnerability }.to be_allowed_for(:developer).of(project) }

  #     it { expect { confirm_vulnerability }.to be_denied_for(:auditor) }
  #     it { expect { confirm_vulnerability }.to be_denied_for(:reporter).of(project) }
  #     it { expect { confirm_vulnerability }.to be_denied_for(:guest).of(project) }
  #     it { expect { confirm_vulnerability }.to be_denied_for(:anonymous) }
  #   end
  # end
end
