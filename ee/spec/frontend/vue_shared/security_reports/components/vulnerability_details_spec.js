import { mount } from '@vue/test-utils';
import createState from 'ee/vue_shared/security_reports/store/state';
import VulnerabilityDetails from 'ee/vue_shared/security_reports/components/vulnerability_details.vue';
import VulnerabilityDetails2 from 'ee/vue_shared/security_reports/components/vulnerability_details_2.vue';
import SeverityBadge from 'ee/vue_shared/security_reports/components/severity_badge.vue';
import SafeLink from 'ee/vue_shared/components/safe_link.vue';
import { TEST_HOST } from 'helpers/test_constants';
import { cloneDeep } from 'lodash';

function makeVulnerability(changes = {}) {
  return Object.assign(cloneDeep(findings[0]), changes);
}

describe('VulnerabilityDetails component', () => {
  let wrapper;

  const componentFactory = vulnerability => {
    wrapper = mount(VulnerabilityDetails2, {
      propsData: { vulnerability },
    });
  };

  const expectSafeLink = (link, { href, text }) => {
    expect(link.is(SafeLink)).toBe(true);
    expect(link.props('href')).toBe(href);
    expect(link.text()).toBe(text);
  };

  fit('renders severity with a badge', () => {
    const vulnerability = makeVulnerability({ severity: 'critical' });
    componentFactory(vulnerability);
    const badge = wrapper.find(SeverityBadge);

    expect(badge.props('severity')).toBe(vulnerability.severity);
  });

  fit('renders link fields with link', () => {
    const vulnerability = makeVulnerability();
    componentFactory(vulnerability);

    expectSafeLink(wrapper.find('.js-link-project'), {
      href: vulnerability.project.full_path,
      text: vulnerability.project.full_name,
    });
  });

  fit('renders wrapped file paths', () => {
    const vulnerability = makeVulnerability({
      blob_path: `${TEST_HOST}/bar`,
      location: {
        file: '/some/file/path',
      },
    });

    componentFactory(vulnerability);

    const link = wrapper
      .findAll(SafeLink)
      .filter(wrapper => wrapper.classes('js-link-file'))
      .at(0);

    expect(link.html()).toMatch('/<wbr>some/<wbr>file/<wbr>path');
  });

  fit('escapes wrapped file paths', () => {
    const vulnerability = makeVulnerability({
      blob_path: `${TEST_HOST}/bar`,
      location: {
        file: '/unsafe/path<script></script>',
      },
    });

    componentFactory(vulnerability);

    const link = wrapper
      .findAll(SafeLink)
      .filter(wrapper => wrapper.classes('js-link-file'))
      .at(0);

    expect(link.html()).toMatch('/<wbr>unsafe/<wbr>path&lt;script&gt;&lt;/<wbr>script&gt;');
  });

  describe('does not render XSS links', () => {
    // eslint-disable-next-line no-script-url
    const badUrl = 'javascript:alert("")';

    beforeEach(() => {
      const details = createState().modal.data;

      details.file.value = 'badFile.lock';
      details.file.url = badUrl;
      details.links.value = [
        {
          url: badUrl,
        },
      ];
      details.identifiers.value = [
        {
          type: 'CVE',
          name: 'BAD_URL',
          url: badUrl,
        },
      ];
      details.instances.value = [
        {
          param: 'X-Content-Type-Options',
          method: 'GET',
          uri: badUrl,
        },
      ];

      const vulnerability = makeVulnerability({
        blob_path: badUrl,
        location: {
          file: 'badFile.lock',
        },
        links: [{ url: badUrl }],
        identifiers: [{ name: 'BAD_URL', url: badUrl }],
      });

      componentFactory(vulnerability);
    });

    fit('for the link field', () => {
      expectSafeLink(wrapper.find('.js-link-links'), {
        href: badUrl,
        text: badUrl,
      });
    });

    fit('for the identifiers field', () => {
      expectSafeLink(wrapper.find('.js-link-identifiers'), {
        href: badUrl,
        text: 'BAD_URL',
      });
    });

    fit('for the file field', () => {
      expectSafeLink(wrapper.find('.js-link-file'), {
        href: badUrl,
        text: 'badFile.lock',
      });
    });

    it('for the instances field', () => {
      expectSafeLink(wrapper.find('.report-block-list-issue-description-link .break-link'), {
        href: badUrl,
        text: badUrl,
      });
    });
  });

  describe('with instances', () => {
    beforeEach(() => {
      const details = {
        instances: {
          value: [
            { uri: 'http://192.168.32.236:3001/explore?sort=latest_activity_desc' },
            { uri: 'http://192.168.32.236:3001/help/user/group/subgroups/index.md' },
          ],
        },
      };

      componentFactory({ propsData: { details } });
    });

    it('renders instances list', () => {
      const instances = wrapper.findAll('.report-block-list li').wrappers;

      expect(instances[0].text()).toContain(
        'http://192.168.32.236:3001/explore?sort=latest_activity_desc',
      );

      expect(instances[1].text()).toContain(
        'http://192.168.32.236:3001/help/user/group/subgroups/index.md',
      );
    });
  });
});

import mutations from 'ee/vue_shared/security_reports/store/mutations';
import IssueModal from 'ee/vue_shared/security_reports/components/modal.vue';
import { findings } from './mock_findings';

import createDashboardState from 'ee/security_dashboard/store/modules/vulnerabilities/state';
import dashboardMutations from 'ee/security_dashboard/store/modules/vulnerabilities/mutations';

describe('VulnerabilityDetails component pin tests', () => {
  let wrapper;

  const mrFactory = vulnFinding => {
    const state = createState();
    mutations.SET_ISSUE_MODAL_DATA(state, { issue: vulnFinding });
    const details = IssueModal.computed.valuedFields.call({
      ...state,
      vulnerability: vulnFinding,
    });

    wrapper = mount(VulnerabilityDetails, {
      propsData: {
        details,
      },
    });
  };

  const dashboardFactory = vulnFinding => {
    const state = createDashboardState();
    dashboardMutations.SET_MODAL_DATA(state, { vulnerability: vulnFinding });
    const details = IssueModal.computed.valuedFields.call({
      ...state,
      vulnerability: vulnFinding,
    });

    wrapper = mount(VulnerabilityDetails, {
      propsData: {
        details,
      },
    });
  };

  const factory = vulnFinding => {
    wrapper = mount(VulnerabilityDetails2, {
      propsData: {
        vulnerability: vulnFinding,
      },
    });
  };

  describe('in grouped_security_reports_app', () => {
    it.each(findings.map(v => [v.name, v]))('works for %s', (_, finding) => {
      mrFactory(finding);
      expect(wrapper.element).toMatchSnapshot();
    });
  });

  describe('in Security Dashboards', () => {
    it.each(findings.map(v => [v.name, v]))('works for %s', (_, finding) => {
      dashboardFactory(finding);
      expect(wrapper.element).toMatchSnapshot();
    });
  });
});
