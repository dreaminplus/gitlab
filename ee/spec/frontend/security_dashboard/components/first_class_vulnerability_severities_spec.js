import Vuex from 'vuex';
import { shallowMount, createLocalVue } from '@vue/test-utils';
import { GlLink } from '@gitlab/ui';
import { trimText } from 'helpers/text_helper';
import {
  severityGroupTypes,
  severityLevelsTranslations,
} from 'ee/security_dashboard/store/modules/vulnerable_projects/constants';
import { Accordion, AccordionItem } from 'ee/vue_shared/components/accordion';
import VulnerabilitySeverity from 'ee/security_dashboard/components/first_class_vulnerability_severities.vue';

const localVue = createLocalVue();
localVue.use(Vuex);

describe('Vulnerability Severity component', () => {
  let wrapper;

  const helpPagePath = 'http://localhost/help-me';
  const projects = [
    {
      id: 'gid://gitlab/Project/11',
      name: 'Security Reports Internal',
      nameWithNamespace: 'Administrator / Security Reports Internal',
      fullPath: 'root/security-reports-internal',
      vulnerabilitySeveritiesCount: {
        critical: 2,
        high: 1,
        info: 0,
        low: 2,
        medium: 5,
        unknown: 3,
      },
    },
    {
      id: 'gid://gitlab/Project/1',
      name: 'Gitlab Test',
      nameWithNamespace: 'Gitlab Org / Gitlab Test',
      fullPath: 'gitlab-org/gitlab-test',
      vulnerabilitySeveritiesCount: {
        critical: 0,
        high: 0,
        info: 1,
        low: 0,
        medium: 4,
        unknown: 0,
      },
    },
  ];

  const createWrapper = ({ propsData }) => {
    return shallowMount(VulnerabilitySeverity, {
      localVue,
      propsData: {
        helpPagePath,
        ...propsData,
      },
      stubs: {
        Accordion,
        AccordionItem,
      },
    });
  };

  const findHelpLink = () => wrapper.find(GlLink);
  const findHeader = () => wrapper.find('h4');
  const findDescription = () => wrapper.find('p');
  const findAccordionItemByGrade = grade => wrapper.find({ ref: `accordionItem${grade}` });
  const findProjectName = accordion => accordion.findAll(GlLink);

  afterEach(() => {
    wrapper.destroy();
    wrapper = null;
  });

  beforeEach(() => {
    wrapper = createWrapper({ propsData: { projects } });
  });

  describe('for all cases', () => {
    it('has the link to the help page', () => {
      expect(findHelpLink().attributes('href')).toBe(helpPagePath);
    });

    it('has a correct header', () => {
      expect(findHeader().text()).toBe('Project security status');
    });

    it('has a correct description', () => {
      expect(findDescription().text()).toBe(
        'Projects are graded based on the highest severity vulnerability present',
      );
    });
  });

  describe.each`
    grade                   | relatedProjects               | correspondingMostSevereVulnerability | levels
    ${severityGroupTypes.F} | ${[projects[0]]}              | ${['critical']}                      | ${'Critical'}
    ${severityGroupTypes.D} | ${[projects[0]]}              | ${['high']}                          | ${'High or unknown'}
    ${severityGroupTypes.C} | ${[projects[0], projects[1]]} | ${['medium', 'medium']}              | ${'Medium'}
    ${severityGroupTypes.B} | ${[projects[0]]}              | ${['low']}                           | ${'Low'}
    ${severityGroupTypes.A} | ${[]}                         | ${[]}                                | ${'No'}
  `(
    'for grade $grade',
    ({ grade, relatedProjects, correspondingMostSevereVulnerability, levels }) => {
      let accordion;
      let text;

      beforeEach(() => {
        accordion = findAccordionItemByGrade(grade);
        text = trimText(accordion.text());
      });

      it('has a corresponding accordion item', () => {
        expect(accordion).toBeTruthy();
      });

      it('has the projects listed in the accordion item', () => {
        if (relatedProjects.length === 0) {
          expect(text).toContain(`0 projects`);
        } else {
          relatedProjects.forEach((project, i) => {
            const projectLink = findProjectName(accordion).at(i);
            expect(projectLink.text()).toBe(project.nameWithNamespace);
            expect(projectLink.attributes('href')).toBe(`${project.fullPath}/security/dashboard`);
          });
        }
      });

      it('states how many projects are there in the group', () => {
        if (relatedProjects.length > 1) {
          expect(text).toContain(`${projects.length} projects`);
        } else if (relatedProjects.length === 1) {
          expect(text).toContain('1 project');
        } else {
          expect(text).toContain('0 project');
        }
      });

      it('states which levels belong to the group', () => {
        expect(text).toContain(`${levels} vulnerabilities present`);
      });

      it('states the most severe vulnerability', () => {
        if (relatedProjects.length === 0) {
          expect(text).toContain('No vulnerabilities present');
        } else {
          relatedProjects.forEach((project, i) => {
            const mostSevere = correspondingMostSevereVulnerability[i];
            expect(text).toContain(
              `${project.vulnerabilitySeveritiesCount[mostSevere]} ${severityLevelsTranslations[mostSevere]}`,
            );
          });
        }
      });
    },
  );
});
