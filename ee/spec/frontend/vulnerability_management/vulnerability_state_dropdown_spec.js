import Vue from 'vue';
import { mount } from '@vue/test-utils';
import { GlDropdown } from '@gitlab/ui';
import VulnerabilityStateDropdown from 'ee/vulnerability_management/components/vulnerability_state_dropdown.vue';
import { VULNERABILITY_STATES } from 'ee/vulnerability_management/constants';

const vulnerabilityStateEntries = Object.entries(VULNERABILITY_STATES);

// Create a dropdown that by default has the first vulnerability state selected.
function createDropdown(state = vulnerabilityStateEntries[0][0]) {
  return mount(VulnerabilityStateDropdown, {
    propsData: { state },
  });
}

// A selected item has a selected icon as its child.
function isSelected(items) {
  return items.contains('.selected-icon');
}

function isDisabled(item) {
  return item.attributes('disabled') === 'disabled';
}

function getFirstUnselectedItem(dropdown) {
  return dropdown.find('.dropdown-item:not(.selected)');
}

describe('Vulnerability state dropdown component', () => {
  test.each(vulnerabilityStateEntries)(
    'dropdown is created with the passed-in state already selected',
    (stateString, stateObject) => {
      const dropdown = createDropdown(stateString);

      // 'initialState' is what was passed in initially and is used to reset the dropdown if the
      // user closes the dropdown without saving it, 'selected' is the currently-selected value in
      // the dropdown.
      expect(dropdown.vm.initialState).toBe(stateObject);
      expect(dropdown.vm.selected).toBe(stateObject);
      // Check that the dropdown item is selected as well.
      const dropdownItem = dropdown.find(`.dropdown-item.${stateObject.action}`);
      expect(isSelected(dropdownItem)).toBe(true);
    },
  );

  it('if an unknown state is passed in, nothing will be selected by default', () => {
    const dropdown = createDropdown('some unknown state');
    const dropdownItems = dropdown.findAll('.dropdown-item');

    expect(dropdown.vm.initialState).toBe(undefined);
    expect(dropdown.vm.selected).toBe(undefined);
    expect(isSelected(dropdownItems)).toBe(false);
  });

  test.each(vulnerabilityStateEntries)(
    `when the %s dropdown item is clicked, it's the only one selected`,
    (stateString, stateObject) => {
      const dropdown = createDropdown('some unknown state');
      const dropdownItem = dropdown.find(`.dropdown-item.${stateObject.action}`);

      dropdownItem.trigger('click');

      return Vue.nextTick().then(() => {
        // Check that the clicked item is selected.
        expect(isSelected(dropdownItem)).toBe(true);
        // Check that the other items aren't selected.
        const otherItems = dropdown.find(`.dropdown-item:not(.${stateObject.action})`);
        expect(isSelected(otherItems)).toBe(false);
      });
    },
  );

  it('the save button should be enabled/disabled based on if the selected item has changed or not', () => {
    const dropdown = createDropdown();
    const saveButton = dropdown.find('.save-button');
    const selectedItem = dropdown.find('.dropdown-item.selected');
    const unselectedItem = getFirstUnselectedItem(dropdown);

    expect(isDisabled(saveButton)).toBe(true); // Check that the save button starts off as disabled.
    unselectedItem.trigger('click'); // Click on an unselected item.

    return Vue.nextTick()
      .then(() => {
        expect(saveButton.attributes('disabled')).toBeUndefined(); // Check that the save button has been enabled.
        selectedItem.trigger('click'); // Re-select the original item.
      })
      .then(() => {
        expect(isDisabled(saveButton)).toBe(true); // Check that the save button has once again been disabled.
      });
  });

  it('clicking on the save button will close the dropdown and fire a change event', () => {
    const dropdown = createDropdown();
    const unselectedItem = getFirstUnselectedItem(dropdown);
    const saveButton = dropdown.find('.save-button');

    expect(isDisabled(saveButton)).toBe(true); // Check that the save button starts off disabled.
    unselectedItem.trigger('click'); // Click on an unselected item.

    return Vue.nextTick().then(() => {
      saveButton.trigger('click'); // Click on the save button.
      const changeEvent = dropdown.emitted('change');
      expect(changeEvent).toHaveLength(1); // Check that a change event was emitted.
      expect(changeEvent[0][0]).toBeTruthy(); // Check that the change event has been emitted with something as its first parameter.
    });
  });

  it('clicking on the cancel button will close the dropdown without emitting any events', () => {
    const dropdown = createDropdown();
    const unselectedItem = getFirstUnselectedItem(dropdown);
    const saveButton = dropdown.find('.save-button');
    const cancelButton = dropdown.find('.cancel-button');
    const innerDropdown = dropdown.find(GlDropdown);
    const spy = jest.spyOn(innerDropdown.vm, 'hide');

    expect(isDisabled(saveButton)).toBe(true); // Check that the save button starts out disabled.
    unselectedItem.trigger('click'); // Click on an unselected item.

    return Vue.nextTick().then(() => {
      expect(isDisabled(saveButton)).toBe(false); // Check that the save button is enabled.
      cancelButton.trigger('click'); // Click on the cancel button.
      expect(Object.keys(dropdown.emitted())).toHaveLength(0); // Check that no events have been emitted.
      expect(spy).toHaveBeenCalledTimes(1); // Check that hide was called on the GlDropdown.
    });
  });

  it('when the dropdown is closed, the selected item resets back to the initial item', () => {
    const dropdown = createDropdown();
    const innerDropdown = dropdown.find(GlDropdown);
    const unselectedItem = getFirstUnselectedItem(dropdown);

    unselectedItem.trigger('click'); // Click on an unselected item.
    expect(dropdown.vm.selected).not.toBe(dropdown.vm.initialState); // Check that the selected value actually changed.

    innerDropdown.vm.$emit('hide'); // Emit the dropdown hide event.
    expect(dropdown.vm.selected).toBe(dropdown.vm.initialState); // Check that the selected item has reverted back to the initial state.
  });
});
