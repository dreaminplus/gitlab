import Vue from 'vue';
import { mount } from '@vue/test-utils';
import VulnerabilityStateDropdown from 'ee/vulnerability_management/components/vulnerability_state_dropdown.vue';
import { VULNERABILITY_STATES } from 'ee/vulnerability_management/constants';

const vulnerabilityStateEntries = Object.entries(VULNERABILITY_STATES);

describe('Vulnerability state dropdown component', () => {
  let wrapper;

  const createWrapper = (state = vulnerabilityStateEntries[0][0]) => {
    // Create a dropdown that by default has the first vulnerability state selected.
    wrapper = mount(VulnerabilityStateDropdown, {
      propsData: { state },
    });
  };

  // A selected item has a selected icon as its child. We don't use .classes('.selected') here
  // because it only works with .find(), whereas item.contains() works with .find() and .findAll().
  const isSelected = items => items.contains('.selected-icon');
  const isDisabled = item => item.attributes('disabled') === 'disabled';
  const firstUnselectedItem = () => wrapper.find('.dropdown-item:not(.selected)');
  const selectedItem = () => wrapper.find('.dropdown-item.selected');
  const saveButton = () => wrapper.find({ ref: 'save-button' });
  const cancelButton = () => wrapper.find({ ref: 'cancel-button' });
  const innerDropdown = () => wrapper.find({ ref: 'dropdown' });

  afterEach(() => {
    if (wrapper) {
      wrapper.destroy();
    }
  });

  test.each(vulnerabilityStateEntries)(
    'dropdown is created with the passed-in state already selected',
    (stateString, stateObject) => {
      createWrapper(stateString);

      // 'initialState' is what was passed in initially and is used to reset the dropdown if the
      // user closes the dropdown without saving it, 'selected' is the currently-selected value in
      // the dropdown.
      expect(wrapper.vm.initialState).toBe(stateObject);
      expect(wrapper.vm.selected).toBe(stateObject);
      // Check that the dropdown item is selected as well.
      const dropdownItem = wrapper.find(`.dropdown-item.${stateObject.action}`);
      expect(isSelected(dropdownItem)).toBe(true);
    },
  );

  it('if an unknown state is passed in, nothing will be selected by default', () => {
    createWrapper('some unknown state');
    const dropdownItems = wrapper.findAll('.dropdown-item');

    expect(wrapper.vm.initialState).toBe(undefined);
    expect(wrapper.vm.selected).toBe(undefined);
    expect(isSelected(dropdownItems)).toBe(false);
  });

  test.each(vulnerabilityStateEntries)(
    `when the %s dropdown item is clicked, it's the only one that's selected`,
    (stateString, stateObject) => {
      // Start off with an unknown state so we can click through each item and see it change.
      createWrapper('some unknown state');
      const dropdownItem = wrapper.find(`.dropdown-item.${stateObject.action}`);

      dropdownItem.trigger('click');

      return Vue.nextTick().then(() => {
        // Check that the clicked item is selected.
        expect(isSelected(dropdownItem)).toBe(true);
        // Check that the other items aren't selected.
        const otherItems = wrapper.find(`.dropdown-item:not(.${stateObject.action})`);
        expect(isSelected(otherItems)).toBe(false);
      });
    },
  );

  it('the save button should be enabled/disabled based on if the selected item has changed or not', () => {
    createWrapper();
    const originalItem = selectedItem();

    expect(isDisabled(saveButton())).toBe(true); // Check that the save button starts off as disabled.
    firstUnselectedItem().trigger('click'); // Click on an unselected item.

    return Vue.nextTick()
      .then(() => {
        expect(isDisabled(saveButton())).toBe(false); // Check that the save button has been enabled.
        originalItem.trigger('click'); // Re-select the original item.
      })
      .then(Vue.nextTick)
      .then(() => {
        expect(isDisabled(saveButton())).toBe(true); // Check that the save button has once again been disabled.
      });
  });

  it('clicking on the save button will close the dropdown and fire a change event', () => {
    createWrapper();

    expect(isDisabled(saveButton())).toBe(true); // Check that the save button starts off disabled.
    firstUnselectedItem().trigger('click'); // Click on an unselected item.

    return Vue.nextTick().then(() => {
      saveButton().trigger('click'); // Click on the save button.
      const changeEvent = wrapper.emitted('change');
      expect(changeEvent).toHaveLength(1); // Check that a change event was emitted.
      expect(changeEvent[0][0]).toBeTruthy(); // Check that the change event has been emitted with something as its first parameter.
    });
  });

  it('clicking on the cancel button will close the dropdown without emitting any events', () => {
    createWrapper();
    const spy = jest.spyOn(innerDropdown().vm, 'hide');

    expect(isDisabled(saveButton())).toBe(true); // Check that the save button starts out disabled.
    firstUnselectedItem().trigger('click'); // Click on an unselected item.

    return Vue.nextTick().then(() => {
      expect(isDisabled(saveButton())).toBe(false); // Check that the save button is enabled.
      cancelButton().trigger('click'); // Click on the cancel button.
      expect(Object.keys(wrapper.emitted())).toHaveLength(0); // Check that no events have been emitted.
      expect(spy).toHaveBeenCalledTimes(1); // Check that hide was called on the inner dropdown.
    });
  });

  it('when the dropdown is closed, the selected item resets back to the initial item', () => {
    createWrapper();

    firstUnselectedItem().trigger('click'); // Click on an unselected item.
    expect(wrapper.vm.selected).not.toBe(wrapper.vm.initialState); // Check that the selected value actually changed.

    innerDropdown().vm.$emit('hide'); // Emit the dropdown hide event.
    expect(wrapper.vm.selected).toBe(wrapper.vm.initialState); // Check that the selected item has reverted back to the initial state.
  });
});
