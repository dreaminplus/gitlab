import Vue from 'vue';
import { shallowMount } from '@vue/test-utils';
import { GlBadge } from '@gitlab/ui';
import MockAdapter from 'axios-mock-adapter';
import axios from '~/lib/utils/axios_utils';
import createFlash from '~/flash';
import waitForPromises from 'helpers/wait_for_promises';
import App from 'ee/vulnerability_management/components/app.vue';
import VulnerabilityStateDropdown from 'ee/vulnerability_management/components/vulnerability_state_dropdown.vue';
import { VULNERABILITY_STATES } from 'ee/vulnerability_management/constants';

const vulnerabilityStateEntries = Object.entries(VULNERABILITY_STATES);
const mockAxios = new MockAdapter(axios);
jest.mock('~/flash');

describe('Vulnerability management app', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = shallowMount(App, {
      propsData: {
        vulnerability: { state: 'detected', created_at: new Date().toISOString() },
        pipeline: { created_at: new Date().toISOString() },
      },
    });
  });

  afterEach(() => {
    wrapper.destroy();
    mockAxios.reset();
    createFlash.mockReset();
  });

  it('the vulnerability state dropdown is rendered', () => {
    expect(wrapper.find(VulnerabilityStateDropdown).exists()).toBe(true);
  });

  it('when the vulnerability state dropdown emits a change event, a POST API call is made', () => {
    const dropdown = wrapper.find(VulnerabilityStateDropdown);
    mockAxios.onPost().reply(201);

    dropdown.vm.$emit('change');

    return waitForPromises().then(() => {
      expect(mockAxios.history.post).toHaveLength(1); // Check that a POST request was made.
    });
  });

  it('when the vulnerability state changes but the API call fails, an error message is displayed', () => {
    const dropdown = wrapper.find(VulnerabilityStateDropdown);
    mockAxios.onPost().reply(400);

    dropdown.vm.$emit('change');

    return waitForPromises().then(() => {
      expect(mockAxios.history.post).toHaveLength(1);
      expect(createFlash).toHaveBeenCalledTimes(1);
    });
  });

  test.each(vulnerabilityStateEntries)(
    'the vulnerability state badge has the correct variant for the %s state',
    (stateString, stateObject) => {
      const badge = wrapper.find(GlBadge);

      wrapper.vm.state = stateString;

      return Vue.nextTick().then(() => {
        expect(badge.attributes('variant')).toBe(stateObject.variant);
      });
    },
  );
});
