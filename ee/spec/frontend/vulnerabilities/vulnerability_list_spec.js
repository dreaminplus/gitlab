import { mount } from '@vue/test-utils';
import { GlEmptyState, GlSkeletonLoading } from '@gitlab/ui';
import RemediatedBadge from 'ee/vulnerabilities/components/remediated_badge.vue';
import VulnerabilityList from 'ee/vulnerabilities/components/vulnerability_list.vue';
import { generateVulnerabilities, vulnerabilities } from './mock_data';

describe('Vulnerability list component', () => {
  let wrapper;

  const defaultData = {
    selectedVulnerabilities: {},
  };

  const createWrapper = ({ props = {}, data = defaultData }) => {
    return mount(VulnerabilityList, {
      propsData: {
        dashboardDocumentation: '#',
        emptyStateSvgPath: '#',
        vulnerabilities: [],
        refetchVulnerabilities: jest.fn(),
        ...props,
      },
      stubs: {
        GlPopover: true,
      },
      data: () => data,
      attachToDocument: true,
    });
  };

  const findCell = label => wrapper.find(`.js-${label}`);
  const findRow = (index = 0) => wrapper.findAll('tbody tr').at(index);

  afterEach(() => wrapper.destroy());

  describe('with vulnerabilities', () => {
    let newVulnerabilities;

    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      wrapper = createWrapper({ props: { vulnerabilities: newVulnerabilities } });
    });

    it('should render a list of vulnerabilities', () => {
      expect(wrapper.findAll('.js-status')).toHaveLength(newVulnerabilities.length);
    });

    it('should correctly render the status', () => {
      const cell = findCell('status');

      expect(cell.text()).toEqual(newVulnerabilities[0].state);
    });

    it('should correctly render the severity', () => {
      const cell = findCell('severity');
      expect(cell.text().toLowerCase()).toEqual(newVulnerabilities[0].severity);
    });

    it('should correctly render the description', () => {
      const cell = findCell('description');

      expect(cell.text()).toEqual(newVulnerabilities[0].title);
    });
  });

  describe('when a vulnerability is resolved on the default branch', () => {
    let newVulnerabilities;

    beforeEach(() => {
      newVulnerabilities = generateVulnerabilities();
      newVulnerabilities[0].resolved_on_default_branch = true;
      wrapper = createWrapper({ props: { vulnerabilities: newVulnerabilities } });
    });

    it('should render the remediated info badge on the first vulnerability', () => {
      const row = findRow(0);
      const badge = row.find(RemediatedBadge);

      expect(badge.exists()).toEqual(true);
    });

    it('should not render the remediated info badge on the second vulnerability', () => {
      const row = findRow(1);
      const badge = row.find(RemediatedBadge);

      expect(badge.exists()).toEqual(false);
    });
  });

  describe('when loading', () => {
    beforeEach(() => {
      wrapper = createWrapper({ props: { isLoading: true } });
    });

    it('should show the loading state', () => {
      expect(findCell('status').exists()).toEqual(false);
      expect(wrapper.find(GlSkeletonLoading).exists()).toEqual(true);
    });
  });

  describe('with no vulnerabilities', () => {
    beforeEach(() => {
      wrapper = createWrapper({});
    });

    it('should show the empty state', () => {
      expect(findCell('status').exists()).toEqual(false);
      expect(wrapper.find(GlEmptyState).exists()).toEqual(true);
    });
  });

  describe('computed', () => {
    beforeEach(() => {
      const newVulnerabilities = generateVulnerabilities();
      wrapper = createWrapper({ props: { vulnerabilities: newVulnerabilities } });
    });

    describe('hasSelectedAllVulnerabilities', () => {
      it('returns true when all vulnerabilities are selected', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' }, id_1: { id: 'id_1' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
        expect(wrapper.vm.hasSelectedAllVulnerabilities).toBe(true);
      });

      it('returns false when some vulnerabilities are selected', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
        expect(wrapper.vm.hasSelectedAllVulnerabilities).toBe(false);
      });

      it('returns false when zero vulnerabilities are selected', () => {
        expect(wrapper.vm.hasSelectedAllVulnerabilities).toBe(false);
      });
    });

    describe('numOfSelectedVulnerabilities', () => {
      it('returns the correct number of selected vulnerabilties when there are zero', () => {
        expect(wrapper.vm.numOfSelectedVulnerabilities).toBe(0);
      });

      it('returns the correct number of selected vulnerabilties when there are more than zero', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' }, id_1: { id: 'id_1' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
        expect(wrapper.vm.numOfSelectedVulnerabilities).toBe(
          Object.keys(selectedVulnerabilities).length,
        );
      });
    });
    describe('shouldShowSelectionSummary', () => {
      it('returns false when shouldShowSelection is true and numOfSelectedVulnerabilities is falsey', () => {
        wrapper = createWrapper({});
        expect(wrapper.vm.shouldShowSelectionSummary).toBe(false);
      });

      it('returns false when shouldShowSelection is false and numOfSelectedVulnerabilities is truthy', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' }, id_1: { id: 'id_1' } };
        wrapper = createWrapper({
          props: { vulnerabilities, refetchVulnerabilities: undefined },
          data: { selectedVulnerabilities },
        });
        expect(wrapper.vm.shouldShowSelectionSummary).toBe(false);
      });

      it('returns false when shouldShowSelection is false and numOfSelectedVulnerabilities is falsey', () => {
        wrapper = createWrapper({ props: { refetchVulnerabilities: undefined } });
        expect(wrapper.vm.shouldShowSelectionSummary).toBe(false);
      });

      it('returns true when shouldShowSelection and numOfSelectedVulnerabilities is truthy', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' }, id_1: { id: 'id_1' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
        expect(wrapper.vm.shouldShowSelectionSummary).toBe(true);
      });
    });
    describe('shouldShowSelection', () => {
      it('returns true when refetchVulnerabilities is provided', () => {
        expect(wrapper.vm.shouldShowSelection).toBe(true);
      });

      it('returns false when refetchVulnerabilities is not provided', () => {
        wrapper = createWrapper({ props: { refetchVulnerabilities: undefined } });
        expect(wrapper.vm.shouldShowSelection).toBe(false);
      });
    });
    describe('checkboxClass', () => {
      it('returns an empty string when refetchVulnerabilities is provided', () => {
        expect(wrapper.vm.checkboxClass).toBe('gl-w-8');
      });

      it('returns the class d-none when refetchVulnerabilities is not provided', () => {
        wrapper = createWrapper({ props: { refetchVulnerabilities: undefined } });
        expect(wrapper.vm.checkboxClass).toBe('d-none');
      });
    });
  });

  describe('methods', () => {
    beforeEach(() => {
      const selectedVulnerabilities = { id_0: { id: 'id_0' }, id_1: { id: 'id_1' } };
      wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
    });
    describe('selectAllVulnerabilities', () => {
      it('should populate this.selectedVulnerabilities with all vulnerabilities', () => {
        wrapper = createWrapper({ props: { vulnerabilities } });
        wrapper.vm.selectAllVulnerabilities();
        expect(Object.keys(wrapper.vm.selectedVulnerabilities).length).toBe(vulnerabilities.length);
      });
    });

    describe('deselectAllVulnerabilities', () => {
      it('should set this.selectedVulnerabilities to an empty object', () => {
        wrapper.vm.deselectAllVulnerabilities();
        expect(wrapper.vm.selectedVulnerabilities).toEqual({});
      });
    });

    describe('isSelected', () => {
      it('should return true for a vulnerability that is in this.selectedVulnerabilities', () => {
        expect(wrapper.vm.isSelected({ id: 'id_0' })).toBe(true);
      });

      it('should return false for a vulnerability that is not in this.selectedVulnerabilities', () => {
        expect(wrapper.vm.isSelected({ id: '3' })).toBe(false);
      });

      it('should return false for not passing in a vulnerability', () => {
        expect(wrapper.vm.isSelected()).toBe(false);
      });
    });

    describe('toggleAllVulnerabilities', () => {
      it('should call selectAllVulnerabilities if no vulnerabilities are selected', () => {
        wrapper = createWrapper({
          props: { vulnerabilities },
          data: { selectedVulnerabilities: {} },
        });
        const spy = jest.spyOn(wrapper.vm, 'selectAllVulnerabilities');
        wrapper.vm.toggleAllVulnerabilities();
        expect(spy).toHaveBeenCalled();
      });

      it('should call selectAllVulnerabilities if some vulnerabilities are selected', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
        const spy = jest.spyOn(wrapper.vm, 'selectAllVulnerabilities');
        wrapper.vm.toggleAllVulnerabilities();
        expect(spy).toHaveBeenCalled();
      });

      it('should call deselectAllVulnerabilities if all vulnerabilities are selected', () => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' }, id_1: { id: 'id_1' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
        const spy = jest.spyOn(wrapper.vm, 'deselectAllVulnerabilities');
        wrapper.vm.toggleAllVulnerabilities();
        expect(spy).toHaveBeenCalled();
      });
    });

    describe('toggleVulnerabilities', () => {
      beforeEach(() => {
        const selectedVulnerabilities = { id_0: { id: 'id_0' } };
        wrapper = createWrapper({ props: { vulnerabilities }, data: { selectedVulnerabilities } });
      });

      it('should add a vulnerability to selectedVulnerabilities if it is not in there already', () => {
        const newVulnerability = vulnerabilities[1];
        wrapper.vm.toggleVulnerability(newVulnerability);
        expect(Object.keys(wrapper.vm.selectedVulnerabilities).length).toBe(2);
      });

      it('should remove a vulnerability from selectedVulnerabilities if it is in there already', () => {
        const existingVulnerability = vulnerabilities[0];
        wrapper.vm.toggleVulnerability(existingVulnerability);
        expect(Object.keys(wrapper.vm.selectedVulnerabilities).length).toBe(0);
      });

      it('should do nothing if it is not passed anything', () => {
        wrapper.vm.toggleVulnerability();
        expect(Object.keys(wrapper.vm.selectedVulnerabilities).length).toBe(1);
      });
    });
  });
});
